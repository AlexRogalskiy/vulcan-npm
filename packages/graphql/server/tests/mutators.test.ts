import expect from "expect";
// import sinon from "sinon/pkg/sinon.js";
import { extendModel } from "../../extendModel";

import {
  createMutator,
  updateMutator,
  deleteMutator,
} from "../resolvers/mutators";
import merge from "lodash/merge";
//import StubCollections from 'meteor/hwillson:stub-collections';
// import Users from "meteor/vulcan:users";

const test = it; // TODO: just before we switch to jest

// stub collection
// import {
//   getDefaultResolvers,
//   getDefaultMutations,
//   addCallback,
//   removeAllCallbacks,
//   createCollection,
// } from "meteor/vulcan:core";
// import { initServerTest } from "meteor/vulcan:test";
import { createModel } from "@vulcanjs/model";
import { VulcanGraphqlModel } from "../../typings";
import { Connector } from "../resolvers/typings";
import { modifierToData } from "../resolvers/validation";

const schema = {
  _id: {
    type: String,
    canRead: ["guests"],
    optional: true,
  },
  foo2: {
    type: String,
    canCreate: ["guests"],
    canRead: ["guests"],
    canUpdate: ["guests"],
  },
  // generated by a callback
  after: {
    required: false,
    type: String,
    canCreate: ["guests"],
    canRead: ["guests"],
    canUpdate: ["guests"],
  },
  // generated by onCreate/onUpdate
  publicAuto: {
    optional: true,
    type: String,
    canCreate: ["guests"],
    canRead: ["guests"],
    canUpdate: ["guests"],
    onCreate: () => {
      return "CREATED";
    },
    onUpdate: () => {
      return "UPDATED";
    },
    onDelete: () => {
      return "DELETED";
    },
  },
  privateAuto: {
    optional: true,
    type: String,
    canCreate: ["admins"],
    canRead: ["admins"],
    canUpdate: ["admins"],
    onCreate: () => {
      return "CREATED";
    },
    onUpdate: () => {
      return "UPDATED";
    },
    onDelete: () => {
      return "DELETED";
    },
  },
};
const Foo = createModel({
  schema,
  name: "Foo",
  extensions: [extendModel({ typeName: "Foo", multiTypeName: "Foos" })],
}) as VulcanGraphqlModel;

const currentUser = {};

describe("graphql/resolvers/mutators", function () {
  const defaultArgs = {
    model: Foo,
    document: { foo2: "bar" },
    currentUser: null,
    validate: false,
  };
  const createArgs = {
    ...defaultArgs,
  };
  const updateArgs = {
    ...defaultArgs,
  };
  const defaultContext = {
    model: Foo,
  };

  describe("create and update mutator", () => {
    // create fake context
    const defaultContext: {
      Foo: { connector: Partial<Connector>; model: VulcanGraphqlModel };
    } = {
      Foo: {
        model: Foo,
        connector: {
          create: async () => "1", // returns the new doc id
          findOneById: async () => ({
            id: "1",
          }),
          findOne: async () => ({ id: "1" }),
          update: async () => ({ id: "1" }),
        },
      },
    };
    test("can run createMutator", async function () {
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        context: defaultContext,
        data: { foo: "bar" },
      });
      expect(resultDocument).toBeDefined();
    });
    test("create should not mutate the provided data", async () => {
      const data = { foo: "foo" };
      const dataOriginal = { ...data };
      await createMutator({
        ...createArgs,
        context: defaultContext,
        data,
      });
      expect(data).toEqual(dataOriginal);
    });
    test("update should not mutate the provided data", async () => {
      const data = { _id: "1", foo: "fooUpdate" };
      const dataOriginal = { ...data };
      await updateMutator({
        ...updateArgs,
        dataId: data._id,
        context: defaultContext,
        data,
      });
      expect(data).toEqual(dataOriginal);
    });
  });
  describe("delete mutator", () => {
    const defaultParams = {
      model: Foo,
      context: {},
      asAdmin: true, // bypass field restriction
    };
    test("refuse deletion if selector is empty", async () => {
      const emptySelector = {};

      await expect(
        deleteMutator({ ...defaultParams, selector: emptySelector })
      ).rejects.toThrow();
    });
    test("refuse deletion if doucment is not found", async () => {
      const nullSelector = { documentId: null };

      const context = {
        Foo: {
          connector: {
            findOne: async () => null,
          },
        },
      };
      const params = {
        ...defaultParams,
        context,
      };

      await expect(
        deleteMutator({ ...params, selector: nullSelector })
      ).rejects.toThrow();
    });
    test("accept valid deletions", async () => {
      const validIdSelector = { _id: "foobar" };
      const validDocIdSelector = { documentId: "foobar" };
      const validSlugSelector = { slug: "foobar" };
      const foo = { hello: "world" };

      const context = merge(defaultContext, {
        Foo: {
          connector: {
            findOne: async () => foo,
            delete: async () => foo,
          },
        },
        currentUser, // need a currentUser
      });

      const params = {
        ...defaultParams,
        context,
      };

      await expect(
        deleteMutator({ ...params, selector: validIdSelector })
      ).resolves.toEqual({ data: foo });
      await expect(
        deleteMutator({ ...params, selector: validDocIdSelector })
      ).resolves.toEqual({ data: foo });
      await expect(
        deleteMutator({ ...params, selector: validSlugSelector })
      ).resolves.toEqual({ data: foo });
    });
  });

  describe("field onCreate/onUpdate callbacks", () => {
    const context = merge(defaultContext, {
      Foo: {
        connector: {
          create: async (model, data) => ({
            ...data, // preserve provided data => this is needed to test the callbacks
            id: "1",
          }),
          findOne: async () => ({
            id: "1",
            foo2: "bar",
          }),
          update: async (model, selector, modifier) => ({
            id: "1",
            ...modifierToData(modifier), // we need to preserve the existing document
          }),
        },
      },
    });
    const defaultArgs = {
      model: Foo,
      document: { foo2: "bar" },
      validate: false,
      context,
      // we test while being logged out
      asAdmin: false,
      currentUser: null,
    };
    const createArgs = {
      ...defaultArgs,
    };
    const updateArgs = {
      ...defaultArgs,
    };
    test("run onCreate callbacks during creation and assign returned value", async () => {
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        data: { foo2: "bar" },
      });
      expect(resultDocument.publicAuto).toEqual("CREATED");
    });
    test("run onUpdate callback during update and assign returned value", async () => {
      const { data: foo } = await createMutator({
        ...createArgs,
        data: { foo2: "bar" },
      });
      const { data: resultDocument } = await updateMutator({
        ...updateArgs,
        dataId: foo._id,
        data: { foo2: "update" },
      });
      expect(resultDocument.publicAuto).toEqual("UPDATED");
    });

    test("keep auto generated private fields ", async () => {
      const { data: resultDocument } = await createMutator({
        ...defaultArgs,
        data: { foo2: "bar" },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
    test("keep auto generated private fields during update ", async () => {
      const { data: resultDocument } = await updateMutator({
        ...defaultArgs,
        dataId: "1",
        data: { foo2: "update" },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
  });
  describe("permissions", () => {
    const context = {
      Foo: {
        connector: {
          create: async (model, data) => ({
            ...data, // preserve provided data => this is needed to test the callbacks
            id: "1",
          }),
          findOne: async () => ({
            id: "1",
            foo2: "bar",
          }),
          update: async (model, selector, modifier) => ({
            id: "1",
            ...modifierToData(modifier), // we need to preserve the existing document
          }),
          delete: async () => null,
        },
      },
    };
    const defaultArgs = {
      model: Foo,
      document: { foo2: "bar" },
      validate: false,
      context,
      // we test while being logged out
      asAdmin: false,
      currentUser: null,
    };
    const createArgs = {
      ...defaultArgs,
    };
    const updateArgs = {
      ...defaultArgs,
    };
    test("filter out non allowed field before returning new document", async () => {
      const { data: resultDocument } = await createMutator({
        ...defaultArgs,
        data: { foo2: "bar" },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
    test("filter out non allowed field before returning updated document", async () => {
      const { data: foo } = await createMutator({
        ...defaultArgs,
        data: { foo2: "bar" },
      });
      const { data: resultDocument } = await updateMutator({
        ...defaultArgs,
        dataId: foo._id,
        data: { foo2: "update" },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
    test("filter out non allowed field before returning deleted document", async () => {
      const { data: foo } = await createMutator({
        ...defaultArgs,
        data: { foo2: "bar" },
      });
      const { data: resultDocument } = await deleteMutator({
        ...defaultArgs,
        selector: {
          documentId: foo._id,
        },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
  });

  /*
  describe("create callbacks", () => {
    // before
    test.skip("run before callback before document is saved", function () {
      // TODO get the document in the database
    });
    //after
    test("run after callback  before document is returned", async function () {
      const afterSpy = sinon.spy();
      addCallback("foo2.create.after", (document) => {
        afterSpy();
        document.after = true;
        return document;
      });
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        document: { foo2: "bar" },
      });
      expect(afterSpy.calledOnce).toBe(true);
      expect(resultDocument.after).toBe(true);
    });
    // async
    test("run async callback", async function () {
      // TODO need a sinon stub
      const asyncSpy = sinon.spy();
      addCallback("foo2.create.async", (properties) => {
        asyncSpy(properties);
        // TODO need a sinon stub
        //expect(originalData.after).toBeUndefined()
      });
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        document: { foo2: "bar" },
      });
      expect(asyncSpy.calledOnce).toBe(true);
    });
    test.skip("provide initial data to async callbacks", async function () {
      const asyncSpy = sinon.spy();
      addCallback("foo2.create.after", (document) => {
        document.after = true;
        return document;
      });
      addCallback("foo2.create.async", (properties) => {
        asyncSpy(properties);
        // TODO need a sinon stub
        //expect(originalData.after).toBeUndefined()
      });
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        document: { foo2: "bar" },
      });
      expect(asyncSpy.calledOnce).toBe(true);
      // TODO: check result
    });

    test("should run createMutator", async function () {
      const { data: resultDocument } = await createMutator(defaultArgs);
      expect(resultDocument).toBeDefined();
    });
    // before
    test.skip("run before callback before document is saved", function () {
      // TODO get the document in the database
    });
    //after
    test("run after callback  before document is returned", async function () {
      const afterSpy = sinon.spy();
      addCallback("foo2.create.after", (document) => {
        afterSpy();
        document.after = true;
        return document;
      });
      const { data: resultDocument } = await createMutator(defaultArgs);
      expect(afterSpy.calledOnce).toBe(true);
      expect(resultDocument.after).toBe(true);
    });
    // async
    test("run async callback", async function () {
      // TODO need a sinon stub
      const asyncSpy = sinon.spy();
      addCallback("foo2.create.async", (properties) => {
        asyncSpy(properties);
        // TODO need a sinon stub
        //expect(originalData.after).toBeUndefined()
      });
      const { data: resultDocument } = await createMutator(defaultArgs);
      expect(asyncSpy.calledOnce).toBe(true);
    });
    test.skip("provide initial data to async callbacks", async function () {
      const asyncSpy = sinon.spy();
      addCallback("foo2.create.after", (document) => {
        document.after = true;
        return document;
      });
      addCallback("foo2.create.async", (properties) => {
        asyncSpy(properties);
        // TODO need a sinon stub
        //expect(originalData.after).toBeUndefined()
      });
      const { data: resultDocument } = await createMutator(defaultArgs);
      expect(asyncSpy.calledOnce).toBe(true);
      // TODO: check result
    });
  });
  */
});
