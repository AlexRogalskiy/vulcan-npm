import expect from "expect";
// import sinon from "sinon/pkg/sinon.js";
import { extendModel } from "../../../extendModel";

import {
  createMutator,
  updateMutator,
  deleteMutator,
} from "../../resolvers/mutators";
import merge from "lodash/merge";
//import StubCollections from 'meteor/hwillson:stub-collections';
// import Users from "meteor/vulcan:users";

const test = it; // TODO: just before we switch to jest
import { createModel } from "@vulcanjs/model";
import { VulcanGraphqlModel } from "../../../typings";
import { Connector } from "../../resolvers/typings";
import { modifierToData } from "../../resolvers/validation";

const schema = {
  _id: {
    type: String,
    canRead: ["guests"],
    optional: true,
  },
  foo2: {
    type: String,
    canCreate: ["guests"],
    canRead: ["guests"],
    canUpdate: ["guests"],
  },
  // generated by a callback
  after: {
    required: false,
    type: String,
    canCreate: ["guests"],
    canRead: ["guests"],
    canUpdate: ["guests"],
  },
  // generated by onCreate/onUpdate
  publicAuto: {
    optional: true,
    type: String,
    canCreate: ["guests"],
    canRead: ["guests"],
    canUpdate: ["guests"],
    onCreate: () => {
      return "CREATED";
    },
    onUpdate: () => {
      return "UPDATED";
    },
    onDelete: () => {
      return "DELETED";
    },
  },
  privateAuto: {
    optional: true,
    type: String,
    canCreate: ["admins"],
    canRead: ["admins"],
    canUpdate: ["admins"],
    onCreate: () => {
      return "CREATED";
    },
    onUpdate: () => {
      return "UPDATED";
    },
    onDelete: () => {
      return "DELETED";
    },
  },
};
const Foo = createModel({
  schema,
  name: "Foo",
  extensions: [extendModel({ typeName: "Foo", multiTypeName: "Foos" })],
}) as VulcanGraphqlModel;

const currentUser = {};

describe("graphql/resolvers/mutators", function () {
  const defaultArgs = {
    model: Foo,
    document: { foo2: "bar" },
    currentUser: null,
    validate: false,
  };
  const createArgs = {
    ...defaultArgs,
  };
  const updateArgs = {
    ...defaultArgs,
  };
  const defaultContext = {
    model: Foo,
  };

  describe("create and update mutator", () => {
    // create fake context
    const defaultContext: {
      Foo: { connector: Partial<Connector>; model: VulcanGraphqlModel };
    } = {
      Foo: {
        model: Foo,
        connector: {
          create: async () => "1", // returns the new doc id
          findOneById: async () => ({
            id: "1",
          }),
          findOne: async () => ({ id: "1" }),
          update: async () => ({ id: "1" }),
        },
      },
    };
    test("can run createMutator", async function () {
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        context: defaultContext,
        data: { foo: "bar" },
      });
      expect(resultDocument).toBeDefined();
    });
    test("create should not mutate the provided data", async () => {
      const data = { foo: "foo" };
      const dataOriginal = { ...data };
      await createMutator({
        ...createArgs,
        context: defaultContext,
        data,
      });
      expect(data).toEqual(dataOriginal);
    });
    test("update should not mutate the provided data", async () => {
      const data = { _id: "1", foo: "fooUpdate" };
      const dataOriginal = { ...data };
      await updateMutator({
        ...updateArgs,
        dataId: data._id,
        context: defaultContext,
        data,
      });
      expect(data).toEqual(dataOriginal);
    });
  });
  describe("delete mutator", () => {
    const defaultParams = {
      model: Foo,
      context: {},
      asAdmin: true, // bypass field restriction
    };
    test("refuse deletion if selector is empty", async () => {
      const emptySelector = {};

      await expect(
        deleteMutator({ ...defaultParams, selector: emptySelector })
      ).rejects.toThrow();
    });
    test("refuse deletion if doucment is not found", async () => {
      const nullSelector = { documentId: null };

      const context = {
        Foo: {
          connector: {
            findOne: async () => null,
          },
        },
      };
      const params = {
        ...defaultParams,
        context,
      };

      await expect(
        deleteMutator({ ...params, selector: nullSelector })
      ).rejects.toThrow();
    });
    test("accept valid deletions", async () => {
      const validIdSelector = { _id: "foobar" };
      const validDocIdSelector = { documentId: "foobar" };
      const validSlugSelector = { slug: "foobar" };
      const foo = { hello: "world" };

      const context = merge({}, defaultContext, {
        Foo: {
          connector: {
            findOne: async () => foo,
            delete: async () => foo,
          },
        },
        currentUser, // need a currentUser
      });

      const params = {
        ...defaultParams,
        context,
      };

      await expect(
        deleteMutator({ ...params, selector: validIdSelector })
      ).resolves.toEqual({ data: foo });
      await expect(
        deleteMutator({ ...params, selector: validDocIdSelector })
      ).resolves.toEqual({ data: foo });
      await expect(
        deleteMutator({ ...params, selector: validSlugSelector })
      ).resolves.toEqual({ data: foo });
    });
  });

  describe("field onCreate/onUpdate callbacks", () => {
    const context = merge({}, defaultContext, {
      Foo: {
        connector: {
          create: async (data) => ({
            ...data, // preserve provided data => this is needed to test the callbacks
            id: "1",
          }),
          findOne: async () => ({
            id: "1",
            foo2: "bar",
          }),
          update: async (selector, modifier) => ({
            id: "1",
            ...modifierToData(modifier), // we need to preserve the existing document
          }),
        },
      },
    });
    const defaultArgs = {
      model: Foo,
      document: { foo2: "bar" },
      validate: false,
      context,
      // we test while being logged out
      asAdmin: false,
      currentUser: null,
    };
    const createArgs = {
      ...defaultArgs,
    };
    const updateArgs = {
      ...defaultArgs,
    };
    test("run onCreate callbacks during creation and assign returned value", async () => {
      const { data: resultDocument } = await createMutator({
        ...createArgs,
        data: { foo2: "bar" },
      });
      expect(resultDocument.publicAuto).toEqual("CREATED");
    });
    test("run onUpdate callback during update and assign returned value", async () => {
      const { data: foo } = await createMutator({
        ...createArgs,
        data: { foo2: "bar" },
      });
      const { data: resultDocument } = await updateMutator({
        ...updateArgs,
        dataId: foo._id,
        data: { foo2: "update" },
      });
      expect(resultDocument.publicAuto).toEqual("UPDATED");
    });

    test("keep auto generated private fields ", async () => {
      const { data: resultDocument } = await createMutator({
        ...defaultArgs,
        data: { foo2: "bar" },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
    test("keep auto generated private fields during update ", async () => {
      const { data: resultDocument } = await updateMutator({
        ...defaultArgs,
        dataId: "1",
        data: { foo2: "update" },
      });
      expect(resultDocument.privateAuto).not.toBeDefined();
    });
  });
  describe("ownership", () => {
    test("add userId if currentUser is defined and schema accept it", async () => {
      const schema = {
        _id: {
          type: String,
        },
        userId: {
          type: String,
          canRead: ["guests"],
        },
      };
      const Foo = createModel({
        schema,
        name: "Foo",
        extensions: [extendModel({ typeName: "Foo", multiTypeName: "Foos" })],
      }) as VulcanGraphqlModel;
      const context = merge({}, defaultContext, {
        currentUser: { _id: "42" },
        Foo: {
          model: Foo,
          connector: { create: async (data) => ({ _id: 1, ...data }) },
        },
      });
      const { data: resultDocument } = await createMutator({
        ...defaultArgs,
        model: Foo,
        context,
        data: {},
      });
      expect(resultDocument.userId).toEqual("42");
    });
  });
  describe("permissions and validation", () => {
    const context = {
      Foo: {
        connector: {
          create: async (data) => ({
            ...data, // preserve provided data => this is needed to test the callbacks
            id: "1",
          }),
          findOne: async () => ({
            id: "1",
            foo2: "bar",
          }),
          update: async (selector, modifier) => ({
            id: "1",
            ...modifierToData(modifier), // we need to preserve the existing document
          }),
          delete: async () => null,
        },
      },
    };
    const defaultArgs = {
      model: Foo,
      document: { foo2: "bar" },
      validate: false,
      context,
      // we test while being logged out
      asAdmin: false,
      currentUser: null,
    };
    describe("fields filtering", () => {
      test("filter out non allowed field before returning new document", async () => {
        const { data: resultDocument } = await createMutator({
          ...defaultArgs,
          data: { foo2: "bar" },
        });
        expect(resultDocument.privateAuto).not.toBeDefined();
      });
      test("filter out non allowed field before returning updated document", async () => {
        const { data: foo } = await createMutator({
          ...defaultArgs,
          data: { foo2: "bar" },
        });
        const { data: resultDocument } = await updateMutator({
          ...defaultArgs,
          dataId: foo._id,
          data: { foo2: "update" },
        });
        expect(resultDocument.privateAuto).not.toBeDefined();
      });
      test("filter out non allowed field before returning deleted document", async () => {
        const { data: foo } = await createMutator({
          ...defaultArgs,
          data: { foo2: "bar" },
        });
        const { data: resultDocument } = await deleteMutator({
          ...defaultArgs,
          selector: {
            documentId: foo._id,
          },
        });
        expect(resultDocument.privateAuto).not.toBeDefined();
      });
    });
    describe("schema based validation", () => {
      const rawDocument = { foo2: "bar" };
      const expectedDocument = { foo2: "bar", publicAuto: "CREATED" };
      test("can create a valid document with no permission error", async () => {
        const { data: createdDocument } = await createMutator({
          ...defaultArgs,
          validate: true,
          data: rawDocument,
        });
        expect(createdDocument).toEqual(expectedDocument);
      });
    });
  });
});
