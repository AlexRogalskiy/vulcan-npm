---
title: "Custom resolvers"
---
# Why a custom resolver?

A custom resolver is needed for everything that is not a normal CRUD operation.

For example, creating an Article on a blog is a normal CRUD operation, and Vulcan Artemis handles that very well.

However, triggering a spell-check algorithm server side is not a normal CRUD operation. For that you'll want a custom resolver.

## Top-level field resolvers

### Method 1. - Just write your resolver

You can still write an Apollo resolver as usual, as long as the name doesn't clash with an existing resolver generated by Artemis (avoid `createBlogArticle` for instance).

Forget everything about Artemis, you have zero obligation to use any of the helpers we provide.


### Method 2. - Use Artemis mutators to manipulate data

When writing a custom resolver, you will quickly understand why Vulcan Artemis is *so cool*. This is especially true if you need to do a CRUD operation inside your custom resolver. For instance if your resolver must update or create some data from the database.

You may need:

- to check if the user is authorized to do the operation
- to run some callbacks to update related data
- to send a database request

Hopefully, Artemis exposes it's internal logic via the concept of "Mutators".

A mutator is a function that includes all the heavy logic of Artemis. Our GraphQL resolvers
are actually just wrappers around mutator calls.

### /!\ Do not use Vulcan connectors directly to communicate with the database

Connectors are simplified function that fits exactly the need of Artemis CRUD operations. They allow us to support any database.

But they might feel limited if you use them directly. First because they can't support as many functionnalities as a normal database connector. Then because they won't run all the nice logic of Artemis (no permission checks, no callbacks etc.)
  
Instead, either use a `mutator`, or call your database as you would do usually (using `mongo` or `mongoose`, a raw SQL query, etc.).

## Custom field resolvers

## What's the difference with top-level resolvers?

There is "graph" in "GraphQL": this means that GraphQl is very good at fetching data that is linked or related to a specific document. In a blog application, you might want to fetch an Article, all the related Comments.

Field resolvers are function that can get those related data. For instance, they can get the list of Comments based on the id of your Article, or your Twitter description based on your Twitter handle, etc.

### First, assess if a relation is enough for you

First, remember that you don't need a custom field resolvers just to get related data. For instance, if you need the list of comments for an article, based on the `commentIds` field of the Article object, you can define a `relation` in your Vulcan schema.

If you are not in this scenario, you need a custom resolvers.

### Almost the same as top-level resolvers...

Field resolvers behave almost the same as top-level resolvers. So you can either create a fully custom resolver, or use a `mutator` if you must manipulate data.

### ...but use DataSources if possible

The only difference is that, if possible, you should use [DataSources](https://www.apollographql.com/docs/apollo-server/data/data-sources/). DataSources will reduce the number of calls to your database in many scenarios.

As a default, Artemis will generate [Mongo DataSources](https://github.com/GraphQLGuide/apollo-datasource-mongodb) for each model.