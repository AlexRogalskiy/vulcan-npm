/*

FormContainer aka SmartForm

Changes compared to Vulcan Meteor:

- previously was named FormWrapper
- accepts a model instead of collection
- no queryFragmentName (resp. mutation name), instead you need to pass the fragment explicitely

Technically, this is a GraphqlSmartForm, while Form.tsx is the more
generic SmartForm, or a "ModelForm".


---

Generate the appropriate fragment for the current form, then
wrap the main Form component with the necessary HoCs while passing
them the fragment.

This component is itself wrapped with:

- withCurrentUser
- withApollo (used to access the Apollo client for form pre-population)

And wraps the Form component with:

- withNew

Or:

- withSingle
- withUpdate
- withDelete

(When wrapping with withSingle, withUpdate, and withDelete, a special Loader
component is also added to wait for withSingle's loading prop to be false)

*/

import React from "react";
import PropTypes from "prop-types";
// import // withCurrentUser,
// Utils,
// getFragment,
//"meteor/vulcan:core";
import gql from "graphql-tag";

import { callbackProps } from "./propTypes";

import getFormFragments from "./modules/formFragments";
import { VulcanSchema } from "@vulcanjs/schema";
// import { VulcanModel } from "@vulcanjs/model";
import { VulcanGraphqlModel } from "@vulcanjs/graphql";
import { capitalize } from "@vulcanjs/utils";
import {
  useSingle,
  useCreate,
  useUpdate,
  useDelete,
  UseSingleOptions,
} from "@vulcanjs/react-hooks";
import { useVulcanComponents } from "./VulcanComponentsContext";

interface FormContainerProps {
  model: VulcanGraphqlModel;
  /** Document id for edition mode, will automatically fetch the document */
  documentId?: string;
  /** Slug (= human readable unique id) for edition mode, will automatically fetch the document */
  slug?: string;
  /**
   * List only those fields in the form
   */
  fields?: Array<string>;
  /**
   * List default fields + those additional fields as well
   */
  addFields?: Array<string>;
  /** Force a query fragment */
  queryFragment?: string;
  /** Force a mutation fragment */
  mutationFragment?: string;
}
export type SmartFormProps = FormContainerProps;

// Fonctionnal version to be able to use hooks
export const FormContainer = (props: FormContainerProps) => {
  const { model, documentId, slug, fields, addFields } = props;
  const { schema } = model;
  // if a document is being passed, this is an edit form
  const isEdit = documentId || slug;
  const selector = {
    documentId,
    slug,
  };
  const formType = isEdit ? "edit" : "new";
  const VulcanComponents = useVulcanComponents();

  // get fragment used to decide what data to load from the server to populate the form,
  // as well as what data to ask for as return value for the mutation
  // TODO: move out of the component
  //const getFragments = () => {
  let queryFragment;
  let mutationFragment;

  // if queryFragment or mutationFragment props are specified, accept either fragment object or fragment string
  // TODO: not sure we actually need that, gApollo accepts fragments or string normally
  if (props.queryFragment) {
    queryFragment =
      typeof props.queryFragment === "string"
        ? gql`
            ${props.queryFragment}
          `
        : props.queryFragment;
  }
  if (props.mutationFragment) {
    mutationFragment =
      typeof props.mutationFragment === "string"
        ? gql`
            ${props.mutationFragment}
          `
        : props.mutationFragment;
  }

  // same with queryFragmentName and mutationFragmentName
  /*
     if (this.props.queryFragmentName) {
       queryFragment = getFragment(this.props.queryFragmentName);
     }
     if (this.props.mutationFragmentName) {
       mutationFragment = getFragment(this.props.mutationFragmentName);
     }
     */

  if (!queryFragment || !mutationFragment) {
    // autogenerated fragments
    const autoFormFragments = getFormFragments({
      formType,
      model,
      fields,
      addFields,
    });

    queryFragment = queryFragment || autoFormFragments.queryFragment;
    mutationFragment = mutationFragment || autoFormFragments.mutationFragment;
  }

  // get query & mutation fragments from props or else default to same as generatedFragment
  //return {
  //  queryFragment,
  //  mutationFragment,
  //};
  //}

  const prefix = `${model.name}${capitalize(formType)}`;
  // props to pass on to child component (i.e. <Form />)
  const childProps = {
    formType,
    schema,
  };

  // options for useCreate, useUpdate and useDelete
  const mutationOptions = {
    model,
    // collection: this.props.collection,
    fragment: mutationFragment,
  };

  const queryOptions: UseSingleOptions<any> = {
    model,
    // TODO: what this option does?
    // queryName: `${prefix}FormQuery`,
    fragment: queryFragment,
    // fragmentName?
    input: {
      id: documentId,
      enableCache: false,
      // TODO: support slug
    },
    queryOptions: {
      // we always want to load a fresh copy of the document
      fetchPolicy: "network-only" as "network-only", // cast is for fixing annoying TS issue... https://github.com/vuejs/vue-apollo/issues/936
      pollInterval: 0, // no polling, only load data once
      skip: formType === "edit",
    },
  };
  const { data, loading } = useSingle(queryOptions);
  const document = data; // TODO: get the item from data
  // TODO: pass the creation functions down to the Form
  const [createDocument] = useCreate(mutationOptions);
  const [updateDocument] = useUpdate(mutationOptions);
  const [deleteDocument] = useDelete(mutationOptions);

  if (isEdit && loading) {
    return <VulcanComponents.Loading />;
  }
  return (
    <VulcanComponents.Form
      document={document}
      loading={loading}
      createDocument={createDocument}
      updateDocument={updateDocument}
      deleteDocument={deleteDocument}
      {...childProps}
      {...props}
    />
  );
};

/*
FormContainer.propTypes = {
  // main options
  documentId: PropTypes.string, // if a document is passed, this will be an edit form
  mutationFragment: PropTypes.object,
  mutationFragmentName: PropTypes.string,

  // graphQL
  // createFoo, deleteFoo, updateFoo
  // newMutation: PropTypes.func, // the new mutation
  // editMutation: PropTypes.func, // the edit mutation
  // removeMutation: PropTypes.func, // the remove mutation

  // form
  prefilledProps: PropTypes.object,
  layout: PropTypes.string,
  fields: PropTypes.arrayOf(PropTypes.string),
  hideFields: PropTypes.arrayOf(PropTypes.string),
  addFields: PropTypes.arrayOf(PropTypes.string),
  showRemove: PropTypes.bool,
  submitLabel: PropTypes.node,
  cancelLabel: PropTypes.node,
  revertLabel: PropTypes.node,
  repeatErrors: PropTypes.bool,
  warnUnsavedChanges: PropTypes.bool,
  formComponents: PropTypes.object,
  disabled: PropTypes.bool,
  itemProperties: PropTypes.object,
  successComponent: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
  contextName: PropTypes.string,

  // callbacks
  ...callbackProps,

  currentUser: PropTypes.object,
  client: PropTypes.object,
};

FormContainer.defaultProps = {
  layout: "horizontal",
};
*/

/*
registerComponent({
  name: 'SmartForm',
  component: FormContainer,
  hocs: [withCurrentUser, withApollo, withRouter, withCollectionProps],
});
*/

export const SmartForm = FormContainer;

export default FormContainer;
